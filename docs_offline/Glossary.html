<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Glossary.md</title>
<style>
body { font-family: system-ui, Segoe UI, Arial, sans-serif; margin: 2rem; line-height: 1.5; max-width: 1100px; }
pre { white-space: pre-wrap; word-wrap: break-word; background: #f6f8fa; padding: 1rem; border-radius: 12px; }
code { background: #f6f8fa; padding: 0.1rem 0.2rem; border-radius: 6px; }
a { color: #0b57d0; }
table { border-collapse: collapse; }
td, th { border: 1px solid #ddd; padding: 6px 10px; }
</style>
</head>
<body>
<h1>Glossary</h1>

<p>This glossary defines the <em>project terms</em> used across the 47Project Framework docs, schemas, tools, and code.</p>

<h2>Core objects</h2>

<p><strong>Framework (47Project Framework)</strong><br />
The PowerShell-first runtime that loads modules, enforces policy/trust, runs plans, and provides the Nexus Shell UI/CLI.</p>

<p><strong>Nexus Shell</strong><br />
The user-facing launcher surface (menu + CLI). It discovers modules and routes commands through the framework.</p>

<p><strong>Core</strong><br />
Shared framework services (paths/storage, logging, policy, trust, module loader, snapshots, journals, etc.).</p>

<p><strong>Module</strong><br />
A packaged feature with a <code>module.json</code> manifest and an entrypoint (e.g., <code>module.psm1</code>). Modules may expose commands, settings, and doctor checks.</p>

<p><strong>Module API level</strong><br />
A numeric compatibility level that describes the interface contract between the framework and modules. Increment only on breaking changes to module integration.</p>

<p><strong>Capability</strong><br />
A named permission (e.g., <code>cap.inventory.read</code>) that a module <em>requests</em> and policy <em>grants/denies</em>. Capabilities are declared in a catalog.</p>

<p><strong>Policy</strong><br />
Rules that define what is allowed (capabilities, unsafe gates, prompting behavior, admin requirements, etc.). Policy is the framework’s safety boundary.</p>

<p><strong>Unsafe gates</strong><br />
Explicit policy toggles that unlock risky features (e.g., registry edits, external downloads, running unsigned scripts). “Unsafe” can still be permitted—but only intentionally.</p>

<p><strong>Plan</strong><br />
A declarative workflow document that describes steps to execute (validate → hash → optionally sign → run). Plans are designed to be reproducible and auditable.</p>

<p><strong>Plan runner</strong><br />
The execution engine that interprets a plan, enforces policy/trust, produces a journal, and returns structured results.</p>

<p><strong>Bundle (<code>.47bundle</code>)</strong><br />
An offline package format containing plans/modules/assets and manifests/hashes so it can be validated and installed/run without internet.</p>

<p><strong>Repository (repo)</strong><br />
A source of modules/bundles/plans, represented by a signed (or pinned) index document.</p>

<p><strong>Channel</strong><br />
A repo subdivision (e.g., <code>stable</code>, <code>beta</code>, <code>nightly</code>) that controls update cadence and risk tolerance.</p>

<h2>Trust and integrity</h2>

<p><strong>Trust store</strong><br />
Local records of allowed publishers/keys and/or pinned artifact hashes. Used to verify signatures and decide what to accept.</p>

<p><strong>Publisher</strong><br />
An identity that signs artifacts (plans, bundles, repo indexes). Publishers are represented by public keys/certificates.</p>

<p><strong>Hash pinning</strong><br />
Trusting a specific artifact by its cryptographic hash (even if it’s not signed).</p>

<p><strong>Signature verification</strong><br />
Checking that an artifact’s signature matches its contents and the signer is trusted.</p>

<p><strong>Artifact manifest</strong><br />
A list of shipped files + their hashes, used for tamper detection and reproducible releases.</p>

<p><strong>SBOM-lite</strong><br />
A lightweight record of dependencies/tools used to build or run the pack.</p>

<p><strong>Canonical JSON</strong><br />
A deterministic JSON normalization process so hashing/signing yields stable results across machines.</p>

<h2>Safety, diagnostics, and operations</h2>

<p><strong>Quarantine / staging</strong><br />
A temporary location where downloads/extractions are placed and validated (manifest + hashes + signature) before being “activated”.</p>

<p><strong>Safe extraction</strong><br />
Zip/bundle extraction that blocks path traversal (zip-slip), absolute paths, and other unsafe entries.</p>

<p><strong>Snapshot</strong><br />
A saved point-in-time capture of framework state (config, policy, installed modules, and/or pack contents) enabling rollback.</p>

<p><strong>Rollback</strong><br />
Restoring a previous snapshot to undo a failed update or plan run.</p>

<p><strong>Journal</strong><br />
An append-only record of a plan run (step start/end, status, artifacts touched). Used for auditability and resuming.</p>

<p><strong>Doctor</strong><br />
A diagnostic command/surface that checks environment health (and allows modules to contribute health checks).</p>

<h2>Governance and change management</h2>

<p><strong>ADR (Architecture Decision Record)</strong><br />
A small document recording a significant decision and its context, so the team doesn’t re-litigate it later.</p>

<p><strong>RFC (Request For Comments)</strong><br />
A proposal document for changes that impact schemas, execution, trust, policy, or other foundational contracts.</p>

</body>
</html>
